#summary IBM Concurrency testing tool

|| [https://www.research.ibm.com/haifa/projects/verification/contest/ to get it] ||

Many concurrency bugs originate from the need for shared resources, e.g., local memory for multi-threaded applications or network storage for FI applications. Shared memory requires access protection. Inadequate protection results in data corruption or invalid data reads (races). The protection mechanisms themselves can lead to further bugs, notably deadlocks. Other bugs result from broken assumptions about order of actions, or about completion time of actions.

IBM's !ConcurrencyTesting tool, !ConTest for short, main use is to expose and eliminate concurrency-related bugs in parallel and distributed software. The observation underlying !ConTest is that while different concurrency bugs (e.g., races and deadlocks) have different causes, different descriptions and different results, almost all of them can be described, and interpreted, in terms of relative order of messages and events. Therefore, if we exercise many different orders of messages and events, we may expose concurrency bugs. To this end, only the order of concurrent messages and events matters.

Trying all possible interleavings (relative order of concurrent events) is not feasible (except for some trivial cases), because as the size of the application increases the interleaving space quickly becomes intractable. Indeed, !ConTest does not try to do that. It just causes many interleavings to be exercised - orders of magnitude more than would be exercised without it.

!ConTest systematically and transparently schedules the execution of program threads and the sending of messages such that program and interaction scenarios which are likely to contain race conditions, deadlocks and other intermittent bugs - collectively called synchronization problems - are forced to appear with high frequency. In doing so, !ConTest dramatically improves the quality of testing and reduces development expense, as bugs are found earlier in the testing process.

The way in which this is done is by injecting noise before and after concurrent events and before and after message sending. Noise means operations that cause some delay (or promote context switch in multi-threaded applications). This is done randomly, and therefore the order of these messages and events is varied from one execution to another. As more interleavings are explored, more concurrency bugs can be revealed, and this can be done early in testing.

With !ConTest, the impact on the testing effort is minimal. Testers can rerun existing test suites without recompilation of the software under test (but with a greater probability of uncovering synchronization problems). !ConTest is easy to use and typically requires less then one day to set up. !ConTest has been used successfully on industrial size applications and is, in general, a scalable testing solution. !ConTest can also be used to measure test coverage, to aid in debugging, to enable replay, and to present deadlock information.

In a nutshell, !ConTest can perform the following:

  * Causes synchronization problems to more likely surface in testing
  * Support the traditional test coverage models (e.g. branch coverage and method coverage) as well as advanced synchronization coverage models
  * Support partial replay, increasing likelihood that a program scenario which gave rise to a specific synchronization problem will recur
  * Produce useful debugging information

The !ConTest flow is as follows. Given a SUT and a set of test cases for this system (pre-existing or generated by a test generation tool), !ConTest first instruments the SUT to allow various timings of system elements. !ConTest also orders the test cases. The system is then run and the test are executed in the specified order. In case that a bug was exposed it is fixed (externally to !ConTest) and the system is re-tested under !ConTest. In case that no bug was exposed, ordering is changed by !ConTest to cause new interleavings, and the testing is repeated. This cycle proceeds until enough iterations are executed (this number can be set in advance, or depend on time and resource available for testing).

Links:

  * Shmuel Ur's presentation's [https://www.research.ibm.com/haifa/projects/verification/contest/papers/testingConcurrentJune2008ForMS.pdf Testing and Debugging Concurrent Software]